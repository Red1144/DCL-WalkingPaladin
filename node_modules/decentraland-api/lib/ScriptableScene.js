"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const decentraland_rpc_1 = require("decentraland-rpc");
const future_1 = require("./utils/future");
const handlers_1 = require("./handlers");
const interfaces_1 = require("./interfaces");
const vdom_1 = require("./internal/vdom");
const ReplaceWholeTreeException_1 = require("./internal/ReplaceWholeTreeException");
exports.defer = Promise.resolve().then.bind(Promise.resolve());
/** Managed queue of dirty components to be re-rendered */
let items = [];
function enqueueRender(scene) {
    if (!scene._dirty) {
        scene._dirty = true;
        if (items.push(scene) === 1) {
            exports.defer(rerender);
        }
    }
}
function rerender() {
    let p;
    const list = items;
    items = [];
    // tslint:disable-next-line:no-conditional-assignment
    while ((p = list.pop())) {
        if (p._dirty)
            renderScriptableScene(p);
    }
}
function filterNonFalsy($) {
    return !!$;
}
let currentFunctionMap;
const attrRegularExpression = /^on[A-Z]/;
/**
 * This function finds recursively all the /on[A-Z]./ attributes that are also a
 * function, then it replaces the function by a UUID. It stores the reference in
 * the currentFunctionMap
 */
function fixCallbacks(scene, component) {
    currentFunctionMap = scene._functionMap;
    if (!currentFunctionMap) {
        currentFunctionMap = scene._functionMap = new Map();
    }
    else {
        currentFunctionMap.clear();
    }
    if (component) {
        fixAttributes(component);
    }
}
function fixAttributes(node) {
    if (node.attrs) {
        for (let i in node.attrs) {
            if (attrRegularExpression.test(i)) {
                if (typeof node.attrs[i] === 'function') {
                    const fn = node.attrs[i];
                    const id = handlers_1.putHandler(fn);
                    currentFunctionMap.set(id, fn);
                    node.attrs[i] = id;
                }
            }
        }
    }
    if (node.children) {
        for (let i = 0; i < node.children.length; i++) {
            fixAttributes(node.children[i]);
        }
    }
}
function recursiveRender(tree) {
    if (typeof tree === 'string') {
        // tslint:disable-next-line:no-console
        console.error('Warning, you are trying to render a text');
        return null;
    }
    if (typeof tree.tag === 'function') {
        const hoc = tree.tag;
        if (hoc.prototype && hoc.prototype.render) {
            throw new Error('Only function components are allowed');
        }
        return hoc(Object.assign({}, tree.attrs, { children: tree.children }));
    }
    if (!tree || !tree.tag)
        return null;
    return {
        tag: tree.tag,
        attrs: tree.attrs,
        children: tree.children.map(recursiveRender).filter(filterNonFalsy)
    };
}
exports.recursiveRender = recursiveRender;
const fallback = new ReplaceWholeTreeException_1.ReplaceWholeTreeException();
/**
 * Render a ScriptableScene, triggering necessary lifecycle events and taking High-Order ScriptableScenes into account.
 * @param {ScriptableScene} scene
 * @internal
 */
function renderScriptableScene(scene, force) {
    let props = scene.props;
    let state = scene.state;
    let previousProps = scene.prevProps || props;
    let previousState = scene.prevState || state;
    let skip = false;
    const isUpdate = !!scene._component;
    // if updating
    if (isUpdate) {
        scene.props = previousProps;
        scene.state = previousState;
        if (!force && scene.shouldSceneUpdate && scene.shouldSceneUpdate(props, state) === false) {
            skip = true;
        }
        scene.props = props;
        scene.state = state;
    }
    scene.prevProps = scene.prevState = null;
    scene._dirty = false;
    if (!skip) {
        let rendererResult = scene.render(props, state);
        if (!('then' in rendererResult && 'catch' in rendererResult)) {
            rendererResult = Promise.resolve(rendererResult);
        }
        rendererResult
            .then(recursiveRender)
            .then(async (rendered) => {
            if (!rendered) {
                throw new Error('the async render() method yielded an empty result');
            }
            const originalDom = scene._component;
            scene._component = rendered;
            // replace functions by uuids
            fixCallbacks(scene, scene._component);
            if (scene.sceneDidUpdate) {
                await scene.sceneDidUpdate(previousProps, previousState);
            }
            await scene.connectionFuture;
            try {
                if (originalDom) {
                    try {
                        const diff = scene.differ.diff(originalDom, scene._component);
                        const msg = {
                            diff,
                            protocol: 1
                        };
                        await scene.entityController.render(msg);
                    }
                    catch (e) {
                        debugger;
                        throw fallback;
                    }
                }
                else {
                    throw fallback;
                }
            }
            catch (e) {
                if (e.message === interfaces_1.Constants.ReplaceWholeTreeException) {
                    await scene.entityController.render(scene._component);
                }
                else {
                    throw e;
                }
            }
        })
            .catch(err => {
            // tslint:disable-next-line:no-console
            console.error(err);
        });
    }
}
exports.renderScriptableScene = renderScriptableScene;
/**
 * Base Scene class.
 * Provides `setState()` and `forceUpdate()`, which trigger rendering.
 * @public
 *
 * @example
 * class MyFoo extends ScriptableScene {
 *   async render() {
 *     return <sphere />;
 *   }
 * }
 */
class ScriptableScene extends decentraland_rpc_1.Script {
    constructor() {
        super(...arguments);
        // @internal
        this._dirty = true;
        // @internal
        this._functionMap = new Map();
        // @internal
        this.prevProps = null;
        // @internal
        this.prevState = null;
        // @internal
        this._component = null;
        // @internal
        this.differ = new vdom_1.DiffDOM();
        this.state = {};
        // @internal
        this.connectionFuture = future_1.future();
        this.receiveUuidEvent = (event) => {
            const map = this._functionMap;
            if (map) {
                const fn = map.get(event.data.uuid);
                if (fn) {
                    fn(event.data.payload);
                }
            }
        };
    }
    /**
     * Update scene state by copying properties from `state` to `this.state`.
     * @param {object} state A hash of state properties to update with new values
     */
    setState(state) {
        let s = this.state;
        if (!this.prevState)
            this.prevState = Object.assign({}, s);
        Object.assign(s, typeof state === 'function' ? state(s, this.props) : state);
        enqueueRender(this);
    }
    /**
     * Immediately perform a synchronous re-render of the component.
     */
    forceUpdate() {
        renderScriptableScene(this, true);
    }
    /**
     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire
     * protocol.
     *
     * @param event name of the remote event to listen
     * @param handler an async
     */
    subscribeTo(event, handler) {
        // tslint:disable-next-line:no-floating-promises
        this.connectionFuture.then(() => {
            this.eventSubscriber.on(event, x => {
                const ret = handler(x.data);
                if (ret && 'catch' in ret && typeof ret.catch === 'function') {
                    ret.catch(err => this.emit('error', err));
                }
            });
        });
    }
    /**
     * Get a standard ethereum provider
     * Please notice this is highly experimental and might change in the future.
     *
     * method whitelist = [
     *   'eth_sendTransaction',
     *   'eth_getTransactionReceipt',
     *   'eth_estimateGas',
     *   'eth_call',
     *   'eth_getBalance',
     *   'eth_getStorageAt',
     *   'eth_blockNumber',
     *   'eth_getBlockByNumber',
     *   'eth_gasPrice',
     *   'eth_protocolVersion',
     *   'net_version',
     *   'web3_sha3',
     *   'web3_clientVersion',
     *   'eth_getTransactionCount'
     * ]
     */
    async getEthereumProvider() {
        const { EthereumController } = await this.loadAPIs(['EthereumController']);
        return {
            // @internal
            send(message, callback) {
                if (message && callback && callback instanceof Function) {
                    EthereumController.sendAsync(message)
                        .then((x) => callback(null, x))
                        .catch(callback);
                }
                else {
                    throw new Error('Decentraland provider only allows async calls');
                }
            },
            sendAsync(message, callback) {
                EthereumController.sendAsync(message)
                    .then((x) => callback(null, x))
                    .catch(callback);
            }
        };
    }
    // @internal
    async systemDidEnable() {
        this.props = (await this.entityController.getOwnAttributes());
        // we create an event subscriber
        this.eventSubscriber = new decentraland_rpc_1.EventSubscriber(this.entityController);
        this.on('SIGKILL', () => {
            if (this.sceneWillUnmount) {
                this.sceneWillUnmount();
            }
        });
        this.subscribeTo('setAttributes', newProps => {
            this.prevProps = this.props;
            this.props = newProps;
            enqueueRender(this);
        });
        this.connectionFuture.resolve(this);
        renderScriptableScene(this, true);
        this.eventSubscriber.on('uuidEvent', this.receiveUuidEvent);
        if (this.sceneDidMount) {
            await this.sceneDidMount();
        }
    }
}
__decorate([
    decentraland_rpc_1.inject('EntityController'),
    __metadata("design:type", Object)
], ScriptableScene.prototype, "entityController", void 0);
exports.ScriptableScene = ScriptableScene;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0YWJsZVNjZW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjcmlwdGFibGVTY2VuZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHVEQUFrRTtBQUNsRSwyQ0FBdUM7QUFDdkMseUNBQXVDO0FBQ3ZDLDZDQUF5RDtBQUl6RCwwQ0FBeUM7QUFFekMsb0ZBQWdGO0FBRW5FLFFBQUEsS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFBO0FBRW5FLDBEQUEwRDtBQUUxRCxJQUFJLEtBQUssR0FBZ0MsRUFBRSxDQUFBO0FBRTNDLFNBQVMsYUFBYSxDQUFPLEtBQTRCO0lBQ3ZELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFBO1FBQ25CLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDM0IsYUFBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1NBQ2hCO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsU0FBUyxRQUFRO0lBQ2YsSUFBSSxDQUE4QixDQUFBO0lBQ2xDLE1BQU0sSUFBSSxHQUFzQixLQUFLLENBQUE7SUFDckMsS0FBSyxHQUFHLEVBQUUsQ0FBQTtJQUNWLHFEQUFxRDtJQUNyRCxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDLE1BQU07WUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUN2QztBQUNILENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxDQUFNO0lBQzVCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNaLENBQUM7QUFFRCxJQUFJLGtCQUF5QyxDQUFBO0FBQzdDLE1BQU0scUJBQXFCLEdB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RUFBRSxRQUFRLENBQUMsRUFBRTtZQUMzQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUE7WUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFpQixDQUFBO1lBQzlCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUNyQixDQUFDLENBQUMsQ0FBQTtRQUVGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUE7UUFFbkMscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO1FBRWpDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUUzRCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsTUFBTSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUE7U0FDM0I7SUFDSCxDQUFDO0NBV0Y7QUExSkM7SUFEQyx5QkFBTSxDQUFDLGtCQUFrQixDQUFDOzt5REFDUTtBQUZyQywwQ0E0SkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHQsIGluamVjdCwgRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSAnZGVjZW50cmFsYW5kLXJwYydcbmltcG9ydCB7IGZ1dHVyZSB9IGZyb20gJy4vdXRpbHMvZnV0dXJlJ1xuaW1wb3J0IHsgcHV0SGFuZGxlciB9IGZyb20gJy4vaGFuZGxlcnMnXG5pbXBvcnQgeyBJU2ltcGxpZmllZE5vZGUsIENvbnN0YW50cyB9IGZyb20gJy4vaW50ZXJmYWNlcydcbmltcG9ydCB7IEVudGl0eUNvbnRyb2xsZXIsIFJQQ1NlbmRhYmxlTWVzc2FnZSB9IGZyb20gJy4vYXBpcydcbmltcG9ydCB7IElFdmVudE5hbWVzLCBJRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMnXG5cbmltcG9ydCB7IERpZmZET00gfSBmcm9tICcuL2ludGVybmFsL3Zkb20nXG5pbXBvcnQgeyBEaWZmUGFja2V0IH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcydcbmltcG9ydCB7IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gfSBmcm9tICcuL2ludGVybmFsL1JlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24nXG5cbmV4cG9ydCBjb25zdCBkZWZlciA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG5sZXQgaXRlbXM6IFNjcmlwdGFibGVTY2VuZTxhbnksIGFueT5bXSA9IFtdXG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXI8RCwgVD4oc2NlbmU6IFNjcmlwdGFibGVTY2VuZTxELCBUPikge1xuICBpZiAoIXNjZW5lLl9kaXJ0eSkge1xuICAgIHNjZW5lLl9kaXJ0eSA9IHRydWVcbiAgICBpZiAoaXRlbXMucHVzaChzY2VuZSkgPT09IDEpIHtcbiAgICAgIGRlZmVyKHJlcmVuZGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgbGV0IHA6IFNjcmlwdGFibGVTY2VuZSB8IHVuZGVmaW5lZFxuICBjb25zdCBsaXN0OiBTY3JpcHRhYmxlU2NlbmVbXSA9IGl0ZW1zXG4gIGl0ZW1zID0gW11cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgd2hpbGUgKChwID0gbGlzdC5wb3AoKSkpIHtcbiAgICBpZiAocC5fZGlydHkpIHJlbmRlclNjcmlwdGFibGVTY2VuZShwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5vbkZhbHN5KCQ6IGFueSk6ICQgaXMgdHJ1ZSB7XG4gIHJldHVybiAhISRcbn1cblxubGV0IGN1cnJlbnRGdW5jdGlvbk1hcDogTWFwPHN0cmluZywgRnVuY3Rpb24+XG5jb25zdCBhdHRyUmVndWxhckV4cHJlc3Npb24gPSAvXm9uW0EtWl0vXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyByZWN1cnNpdmVseSBhbGwgdGhlIC9vbltBLVpdLi8gYXR0cmlidXRlcyB0aGF0IGFyZSBhbHNvIGFcbiAqIGZ1bmN0aW9uLCB0aGVuIGl0IHJlcGxhY2VzIHRoZSBmdW5jdGlvbiBieSBhIFVVSUQuIEl0IHN0b3JlcyB0aGUgcmVmZXJlbmNlIGluXG4gKiB0aGUgY3VycmVudEZ1bmN0aW9uTWFwXG4gKi9cbmZ1bmN0aW9uIGZpeENhbGxiYWNrcyhzY2VuZTogU2NyaXB0YWJsZVNjZW5lPGFueSwgYW55PiwgY29tcG9uZW50OiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgY3VycmVudEZ1bmN0aW9uTWFwID0gc2NlbmUuX2Z1bmN0aW9uTWFwXG5cbiAgaWYgKCFjdXJyZW50RnVuY3Rpb25NYXApIHtcbiAgICBjdXJyZW50RnVuY3Rpb25NYXAgPSBzY2VuZS5fZnVuY3Rpb25NYXAgPSBuZXcgTWFwKClcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50RnVuY3Rpb25NYXAuY2xlYXIoKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGZpeEF0dHJpYnV0ZXMoY29tcG9uZW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpeEF0dHJpYnV0ZXMobm9kZTogSVNpbXBsaWZpZWROb2RlKSB7XG4gIGlmIChub2RlLmF0dHJzKSB7XG4gICAgZm9yIChsZXQgaSBpbiBub2RlLmF0dHJzKSB7XG4gICAgICBpZiAoYXR0clJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoaSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLmF0dHJzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgZm46IGFueSA9IG5vZGUuYXR0cnNbaV1cbiAgICAgICAgICBjb25zdCBpZCA9IHB1dEhhbmRsZXIoZm4pXG4gICAgICAgICAgY3VycmVudEZ1bmN0aW9uTWFwLnNldChpZCwgZm4pXG4gICAgICAgICAgbm9kZS5hdHRyc1tpXSA9IGlkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZml4QXR0cmlidXRlcyhub2RlLmNoaWxkcmVuW2ldKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaXZlUmVuZGVyKHRyZWU6IElTaW1wbGlmaWVkTm9kZSk6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwge1xuICBpZiAodHlwZW9mIHRyZWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmVycm9yKCdXYXJuaW5nLCB5b3UgYXJlIHRyeWluZyB0byByZW5kZXIgYSB0ZXh0JylcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHR5cGVvZiAodHJlZS50YWcgYXMgYW55KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhvYyA9ICh0cmVlLnRhZyBhcyBhbnkpIGFzIEZ1bmN0aW9uXG4gICAgaWYgKGhvYy5wcm90b3R5cGUgJiYgaG9jLnByb3RvdHlwZS5yZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBmdW5jdGlvbiBjb21wb25lbnRzIGFyZSBhbGxvd2VkJylcbiAgICB9XG4gICAgcmV0dXJuIGhvYyh7IC4uLnRyZWUuYXR0cnMsIGNoaWxkcmVuOiB0cmVlLmNoaWxkcmVuIH0pXG4gIH1cblxuICBpZiAoIXRyZWUgfHwgIXRyZWUudGFnKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgdGFnOiB0cmVlLnRhZyxcbiAgICBhdHRyczogdHJlZS5hdHRycyxcbiAgICBjaGlsZHJlbjogKHRyZWUuY2hpbGRyZW4ubWFwKHJlY3Vyc2l2ZVJlbmRlcikuZmlsdGVyKGZpbHRlck5vbkZhbHN5KSBhcyBhbnkpIGFzIElTaW1wbGlmaWVkTm9kZVtdXG4gIH1cbn1cblxuY29uc3QgZmFsbGJhY2sgPSBuZXcgUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbigpXG5cbi8qKlxuICogUmVuZGVyIGEgU2NyaXB0YWJsZVNjZW5lLCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBTY3JpcHRhYmxlU2NlbmVzIGludG8gYWNjb3VudC5cbiAqIEBwYXJhbSB7U2NyaXB0YWJsZVNjZW5lfSBzY2VuZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPihzY2VuZTogU2NyaXB0YWJsZVNjZW5lPFByb3BzLCBTdGF0ZT4sIGZvcmNlPzogYm9vbGVhbikge1xuICBsZXQgcHJvcHMgPSBzY2VuZS5wcm9wc1xuICBsZXQgc3RhdGUgPSBzY2VuZS5zdGF0ZVxuICBsZXQgcHJldmlvdXNQcm9wcyA9IHNjZW5lLnByZXZQcm9wcyB8fCBwcm9wc1xuICBsZXQgcHJldmlvdXNTdGF0ZSA9IHNjZW5lLnByZXZTdGF0ZSB8fCBzdGF0ZVxuICBsZXQgc2tpcCA9IGZhbHNlXG4gIGNvbnN0IGlzVXBkYXRlID0gISFzY2VuZS5fY29tcG9uZW50XG5cbiAgLy8gaWYgdXBkYXRpbmdcbiAgaWYgKGlzVXBkYXRlKSB7XG4gICAgc2NlbmUucHJvcHMgPSBwcmV2aW91c1Byb3BzXG4gICAgc2NlbmUuc3RhdGUgPSBwcmV2aW91c1N0YXRlXG4gICAgaWYgKCFmb3JjZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZShwcm9wcywgc3RhdGUpID09PSBmYWxzZSkge1xuICAgICAgc2tpcCA9IHRydWVcbiAgICB9XG4gICAgc2NlbmUucHJvcHMgPSBwcm9wc1xuICAgIHNjZW5lLnN0YXRlID0gc3RhdGVcbiAgfVxuXG4gIHNjZW5lLnByZXZQcm9wcyA9IHNjZW5lLnByZXZTdGF0ZSA9IG51bGxcbiAgc2NlbmUuX2RpcnR5ID0gZmFsc2VcblxuICBpZiAoIXNraXApIHtcbiAgICBsZXQgcmVuZGVyZXJSZXN1bHQgPSBzY2VuZS5yZW5kZXIocHJvcHMsIHN0YXRlKVxuXG4gICAgaWYgKCEoJ3RoZW4nIGluIHJlbmRlcmVyUmVzdWx0ICYmICdjYXRjaCcgaW4gcmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICByZW5kZXJlclJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdClcbiAgICB9XG5cbiAgICByZW5kZXJlclJlc3VsdFxuICAgICAgLnRoZW4ocmVjdXJzaXZlUmVuZGVyKVxuICAgICAgLnRoZW4oYXN5bmMgcmVuZGVyZWQgPT4ge1xuICAgICAgICBpZiAoIXJlbmRlcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXN5bmMgcmVuZGVyKCkgbWV0aG9kIHlpZWxkZWQgYW4gZW1wdHkgcmVzdWx0JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRG9tID0gc2NlbmUuX2NvbXBvbmVudFxuXG4gICAgICAgIHNjZW5lLl9jb21wb25lbnQgPSByZW5kZXJlZFxuXG4gICAgICAgIC8vIHJlcGxhY2UgZnVuY3Rpb25zIGJ5IHV1aWRzXG4gICAgICAgIGZpeENhbGxiYWNrcyhzY2VuZSwgc2NlbmUuX2NvbXBvbmVudClcblxuICAgICAgICBpZiAoc2NlbmUuc2NlbmVEaWRVcGRhdGUpIHtcbiAgICAgICAgICBhd2FpdCBzY2VuZS5zY2VuZURpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2NlbmUuY29ubmVjdGlvbkZ1dHVyZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsRG9tKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBkaWZmID0gc2NlbmUuZGlmZmVyLmRpZmYob3JpZ2luYWxEb20sIHNjZW5lLl9jb21wb25lbnQpXG5cbiAgICAgICAgICAgICAgY29uc3QgbXNnOiBEaWZmUGFja2V0ID0ge1xuICAgICAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IDFcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKG1zZylcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBDb25zdGFudHMuUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbikge1xuICAgICAgICAgICAgYXdhaXQgc2NlbmUuZW50aXR5Q29udHJvbGxlci5yZW5kZXIoc2NlbmUuX2NvbXBvbmVudClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPiB7XG4gIHByb3BzOiBQcm9wc1xuICBzdGF0ZTogU3RhdGVcblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjaGFuZ2UgaW4gcHJvcHMgYW5kIHN0YXRlIHNob3VsZCB0cmlnZ2VyIGEgcmUtcmVuZGVyLlxuICAgKlxuICAgKiBJZiBmYWxzZSBpcyByZXR1cm5lZCwgYFNjcmlwdGFibGVTY2VuZSNyZW5kZXJgLCBhbmQgYHNjZW5lRGlkVXBkYXRlYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAqL1xuICBzaG91bGRTY2VuZVVwZGF0ZT8obmV4dFByb3BzOiBQcm9wcywgbmV4dFN0YXRlOiBTdGF0ZSk6IFByb21pc2U8Ym9vbGVhbj4gfCBib29sZWFuXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBzY2VuZSBpcyBkZXN0cm95ZWQuIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGluIHRoaXMgbWV0aG9kLCBzdWNoIGFzXG4gICAqIGNhbmNlbGxlZCBuZXR3b3JrIHJlcXVlc3RzLCBvciBjbGVhbmluZyB1cCBhbnkgZWxlbWVudHMgY3JlYXRlZCBpbiBgc2NlbmVEaWRNb3VudGAuXG4gICAqL1xuICBzY2VuZVdpbGxVbm1vdW50PygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBjb21wb21lbnQgaXMgbW91bnRlZC4gU2V0dGluZyBzdGF0ZSBoZXJlIHdpbGwgdHJpZ2dlciByZS1yZW5kZXJpbmcuXG4gICAqL1xuICBzY2VuZURpZE1vdW50PygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdXBkYXRpbmcgb2NjdXJzLiBOb3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAqL1xuICBzY2VuZURpZFVwZGF0ZT8ocHJldlByb3BzOiBSZWFkb25seTxQcm9wcz4sIHByZXZTdGF0ZTogUmVhZG9ubHk8U3RhdGU+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWRcbn1cblxuLyoqXG4gKiBCYXNlIFNjZW5lIGNsYXNzLlxuICogUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoIHRyaWdnZXIgcmVuZGVyaW5nLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBjbGFzcyBNeUZvbyBleHRlbmRzIFNjcmlwdGFibGVTY2VuZSB7XG4gKiAgIGFzeW5jIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gPHNwaGVyZSAvPjtcbiAqICAgfVxuICogfVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2NyaXB0YWJsZVNjZW5lPFByb3BzID0ge30sIFN0YXRlID0ge30+IGV4dGVuZHMgU2NyaXB0IHtcbiAgQGluamVjdCgnRW50aXR5Q29udHJvbGxlcicpXG4gIGVudGl0eUNvbnRyb2xsZXIhOiBFbnRpdHlDb250cm9sbGVyXG5cbiAgZXZlbnRTdWJzY3JpYmVyITogRXZlbnRTdWJzY3JpYmVyXG5cbiAgLy8gQGludGVybmFsXG4gIF9kaXJ0eSA9IHRydWVcbiAgLy8gQGludGVybmFsXG4gIF9mdW5jdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBGdW5jdGlvbj4oKVxuICAvLyBAaW50ZXJuYWxcbiAgcHJldlByb3BzOiBQcm9wcyB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBwcmV2U3RhdGU6IFN0YXRlIHwgbnVsbCA9IG51bGxcbiAgLy8gQGludGVybmFsXG4gIF9jb21wb25lbnQ6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBkaWZmZXIgPSBuZXcgRGlmZkRPTSgpXG5cbiAgc3RhdGU6IFN0YXRlID0ge30gYXMgU3RhdGVcblxuICAvLyBAaW50ZXJuYWxcbiAgY29ubmVjdGlvbkZ1dHVyZSA9IGZ1dHVyZTxTY3JpcHQ+KClcblxuICBwcm9wcyE6IFByb3BzXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY2VuZSBzdGF0ZSBieSBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBgc3RhdGVgIHRvIGB0aGlzLnN0YXRlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIEEgaGFzaCBvZiBzdGF0ZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlOiBQYXJ0aWFsPFN0YXRlPiB8ICgoc3RhdGU6IFN0YXRlLCBwcm9wczogUHJvcHMpID0+IFBhcnRpYWw8U3RhdGU+KSk6IHZvaWQge1xuICAgIGxldCBzID0gdGhpcy5zdGF0ZVxuICAgIGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcylcbiAgICBPYmplY3QuYXNzaWduKHMsIHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpXG4gICAgZW5xdWV1ZVJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGZvcmNlVXBkYXRlKCkge1xuICAgIHJlbmRlclNjcmlwdGFibGVTY2VuZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAgICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgICAgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnQgZWxlbWVudC9jb21wb25lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlICAgIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBhYnN0cmFjdCBhc3luYyByZW5kZXIocHJvcHM6IFByb3BzLCBzdGF0ZTogU3RhdGUpOiBQcm9taXNlPElTaW1wbGlmaWVkTm9kZT5cblxuICAvKipcbiAgICogSXQgbWFrZXMgYSBzdWJzY3JpcHRpb24gdG8gcmVtb3RlIGV2ZW50cywgdGhvc2UgZXZlbnRzIG9jY3VyIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnYW1lIGFuZCBhcmUgc2VudCB0aHJ1IHRoZSB3aXJlXG4gICAqIHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgbmFtZSBvZiB0aGUgcmVtb3RlIGV2ZW50IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gaGFuZGxlciBhbiBhc3luY1xuICAgKi9cbiAgc3Vic2NyaWJlVG88VCBleHRlbmRzIElFdmVudE5hbWVzPihldmVudDogVCwgaGFuZGxlcjogKGRhdGE6IElFdmVudHNbVF0pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy5jb25uZWN0aW9uRnV0dXJlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudFN1YnNjcmliZXIub24oZXZlbnQsIHggPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBoYW5kbGVyKHguZGF0YSlcbiAgICAgICAgaWYgKHJldCAmJiAnY2F0Y2gnIGluIHJldCAmJiB0eXBlb2YgcmV0LmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YW5kYXJkIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAqIFBsZWFzZSBub3RpY2UgdGhpcyBpcyBoaWdobHkgZXhwZXJpbWVudGFsIGFuZCBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogbWV0aG9kIHdoaXRlbGlzdCA9IFtcbiAgICogICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAqICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgKiAgICdldGhfZXN0aW1hdGVHYXMnLFxuICAgKiAgICdldGhfY2FsbCcsXG4gICAqICAgJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICogICAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAqICAgJ2V0aF9ibG9ja051bWJlcicsXG4gICAqICAgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICogICAnZXRoX2dhc1ByaWNlJyxcbiAgICogICAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAqICAgJ25ldF92ZXJzaW9uJyxcbiAgICogICAnd2ViM19zaGEzJyxcbiAgICogICAnd2ViM19jbGllbnRWZXJzaW9uJyxcbiAgICogICAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnXG4gICAqIF1cbiAgICovXG4gIGFzeW5jIGdldEV0aGVyZXVtUHJvdmlkZXIoKSB7XG4gICAgY29uc3QgeyBFdGhlcmV1bUNvbnRyb2xsZXIgfSA9IGF3YWl0IHRoaXMubG9hZEFQSXMoWydFdGhlcmV1bUNvbnRyb2xsZXInXSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBAaW50ZXJuYWxcbiAgICAgIHNlbmQobWVzc2FnZTogUlBDU2VuZGFibGVNZXNzYWdlLCBjYWxsYmFjaz86IChlcnJvcjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAgIC50aGVuKCh4OiBhbnkpID0+IGNhbGxiYWNrKG51bGwsIHgpKVxuICAgICAgICAgICAgLmNhdGNoKGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjZW50cmFsYW5kIHByb3ZpZGVyIG9ubHkgYWxsb3dzIGFzeW5jIGNhbGxzJylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbmRBc3luYyhtZXNzYWdlOiBSUENTZW5kYWJsZU1lc3NhZ2UsIGNhbGxiYWNrOiAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAudGhlbigoeDogYW55KSA9PiBjYWxsYmFjayhudWxsLCB4KSlcbiAgICAgICAgICAuY2F0Y2goY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBhcyB7XG4gICAgICBzZW5kOiBGdW5jdGlvblxuICAgICAgc2VuZEFzeW5jOiBGdW5jdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBhc3luYyBzeXN0ZW1EaWRFbmFibGUoKSB7XG4gICAgdGhpcy5wcm9wcyA9IChhd2FpdCB0aGlzLmVudGl0eUNvbnRyb2xsZXIuZ2V0T3duQXR0cmlidXRlcygpKSBhcyBQcm9wc1xuXG4gICAgLy8gd2UgY3JlYXRlIGFuIGV2ZW50IHN1YnNjcmliZXJcbiAgICB0aGlzLmV2ZW50U3Vic2NyaWJlciA9IG5ldyBFdmVudFN1YnNjcmliZXIodGhpcy5lbnRpdHlDb250cm9sbGVyKVxuXG4gICAgdGhpcy5vbignU0lHS0lMTCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjZW5lV2lsbFVubW91bnQpIHtcbiAgICAgICAgdGhpcy5zY2VuZVdpbGxVbm1vdW50KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5zdWJzY3JpYmVUbygnc2V0QXR0cmlidXRlcycsIG5ld1Byb3BzID0+IHtcbiAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wc1xuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzIGFzIFByb3BzXG4gICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpXG4gICAgfSlcblxuICAgIHRoaXMuY29ubmVjdGlvbkZ1dHVyZS5yZXNvbHZlKHRoaXMpXG5cbiAgICByZW5kZXJTY3JpcHRhYmxlU2NlbmUodGhpcywgdHJ1ZSlcblxuICAgIHRoaXMuZXZlbnRTdWJzY3JpYmVyLm9uKCd1dWlkRXZlbnQnLCB0aGlzLnJlY2VpdmVVdWlkRXZlbnQpXG5cbiAgICBpZiAodGhpcy5zY2VuZURpZE1vdW50KSB7XG4gICAgICBhd2FpdCB0aGlzLnNjZW5lRGlkTW91bnQoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVjZWl2ZVV1aWRFdmVudCA9IChldmVudDogYW55KSA9PiB7XG4gICAgY29uc3QgbWFwOiBNYXA8c3RyaW5nLCBGdW5jdGlvbj4gPSB0aGlzLl9mdW5jdGlvbk1hcFxuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IGZuID0gbWFwLmdldChldmVudC5kYXRhLnV1aWQpXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZXZlbnQuZGF0YS5wYXlsb2FkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19