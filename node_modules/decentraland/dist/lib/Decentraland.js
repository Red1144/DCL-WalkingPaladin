"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const events = require("wildcards");
const IPFS_1 = require("./IPFS");
const Project_1 = require("./Project");
const Ethereum_1 = require("./Ethereum");
const LinkerAPI_1 = require("./LinkerAPI");
const Preview_1 = require("./Preview");
const project_1 = require("../utils/project");
const errors_1 = require("../utils/errors");
const API_1 = require("./API");
const land_1 = require("../utils/land");
class Decentraland extends events_1.EventEmitter {
    constructor(args = {}) {
        super();
        this.options = {};
        this.options = args;
        this.options.workingDir = args.workingDir || project_1.getRootPath();
        this.localIPFS = new IPFS_1.IPFS(args.ipfsHost, args.ipfsPort);
        this.project = new Project_1.Project(this.options.workingDir);
        this.ethereum = new Ethereum_1.Ethereum();
        this.provider = this.ethereum;
        if (!this.options.blockchain) {
            this.provider = new API_1.API();
        }
        // Pipe all events
        events(this.localIPFS, 'ipfs:*', this.pipeEvents.bind(this));
        events(this.ethereum, 'ethereum:*', this.pipeEvents.bind(this));
    }
    init(sceneMeta, boilerplateType, websocketServer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.project.writeDclIgnore();
            yield this.project.initProject();
            yield this.project.writeSceneFile(sceneMeta);
            yield this.project.scaffoldProject(boilerplateType, websocketServer);
        });
    }
    deploy(files) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.project.validateSceneOptions();
            yield this.validateOwnership();
            const { x, y } = yield this.project.getParcelCoordinates();
            const projectFile = yield this.project.getProjectFile();
            const filesAdded = yield this.localIPFS.addFiles(files);
            const rootFolder = filesAdded[filesAdded.length - 1];
            const ipns = yield this.ethereum.getIPNS(x, y);
            let ipfsKey = projectFile.ipfsKey;
            if (!ipfsKey) {
                ipfsKey = yield this.localIPFS.genIPFSKey(projectFile.id);
                yield this.project.writeProjectFile({ ipfsKey });
                this.localIPFS.genKeySuccess();
            }
            yield this.localIPFS.publish(projectFile.id, `/ipfs/${rootFolder.hash}`);
            if (ipfsKey !== ipns) {
                try {
                    yield this.link();
                }
                catch (e) {
                    errors_1.fail(errors_1.ErrorType.LINKER_ERROR, e.message);
                }
            }
            yield this.pin(rootFolder.hash);
        });
    }
    link() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.project.validateExistingProject();
            yield this.project.validateSceneOptions();
            yield this.validateOwnership();
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const manaContract = yield Ethereum_1.Ethereum.getContractAddress('MANAToken');
                const landContract = yield Ethereum_1.Ethereum.getContractAddress('LANDProxy');
                const estateContract = yield Ethereum_1.Ethereum.getContractAddress('EstateProxy');
                const linker = new LinkerAPI_1.LinkerAPI(this.project, manaContract, landContract, estateContract);
                events(linker, '*', this.pipeEvents.bind(this));
                linker.on('link:success', () => __awaiter(this, void 0, void 0, function* () {
                    resolve();
                }));
                try {
                    yield linker.link(this.options.linkerPort, this.options.isHttps);
                }
                catch (e) {
                    reject(e);
                }
            }));
        });
    }
    pin(ipfsHash) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.project.validateExistingProject();
            const coords = yield this.project.getParcelCoordinates();
            const peerId = yield this.localIPFS.getPeerId();
            yield this.localIPFS.pinFiles(peerId, coords, ipfsHash);
        });
    }
    preview() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.project.validateExistingProject();
            yield this.project.validateSceneOptions();
            const preview = new Preview_1.Preview(yield this.project.getDCLIgnore(), this.getWatch());
            events(preview, '*', this.pipeEvents.bind(this));
            yield preview.startServer(this.options.previewPort);
        });
    }
    getAddressInfo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const [coords, estateIds] = yield Promise.all([this.provider.getLandOf(address), this.provider.getEstatesOf(address)]);
            const pRequests = Promise.all(coords.map(coord => this.provider.getLandData(coord)));
            const eRequests = Promise.all(estateIds.map(estateId => this.provider.getEstateData(estateId)));
            const [pData, eData] = yield Promise.all([pRequests, eRequests]);
            const parcels = pData.map((data, i) => (Object.assign({ x: coords[i].x, y: coords[i].y }, land_1.filterAndFillEmpty(data, '')))) || [];
            const estates = eData.map((data, i) => (Object.assign({ id: parseInt(estateIds[i].toString(), 10) }, land_1.filterAndFillEmpty(data, '')))) || [];
            return { parcels, estates };
        });
    }
    getWatch() {
        return !!this.options.watch;
    }
    getProjectInfo(x, y) {
        return __awaiter(this, void 0, void 0, function* () {
            const scene = yield this.project.getSceneFile();
            const land = yield this.provider.getLandData({ x, y });
            const owner = yield this.provider.getLandOwner({ x, y });
            return { scene, land: Object.assign({}, land, { owner }) };
        });
    }
    getParcelInfo({ x, y }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [scene, land, owner] = yield Promise.all([
                this.localIPFS.getRemoteSceneMetadata(x, y),
                this.provider.getLandData({ x, y }),
                this.provider.getLandOwner({ x, y })
            ]);
            return { scene, land: Object.assign({}, land, { owner }) };
        });
    }
    getEstateInfo(estateId) {
        return __awaiter(this, void 0, void 0, function* () {
            const estate = yield this.provider.getEstateData(estateId);
            if (!estate) {
                return;
            }
            const owner = yield this.provider.getEstateOwner(estateId);
            const parcels = yield this.provider.getLandOfEstate(estateId);
            return Object.assign({}, estate, { owner, parcels });
        });
    }
    getEstateOfParcel(coords) {
        return __awaiter(this, void 0, void 0, function* () {
            const estateId = yield this.provider.getEstateIdOfLand(coords);
            if (!estateId) {
                return;
            }
            return this.getEstateInfo(estateId);
        });
    }
    getParcelStatus(x, y) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url } = yield this.localIPFS.resolveParcel(x, y);
            if (!url)
                return { files: [] };
            const result = { files: url.dependencies };
            if (url.lastModified) {
                // only available in redis metadata >= 2
                result.lastModified = url.lastModified;
            }
            return result;
        });
    }
    pipeEvents(event, ...args) {
        this.emit(event, ...args);
    }
    validateOwnership() {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = yield this.project.getOwner();
            const estate = yield this.project.getEstate();
            if (estate) {
                yield this.ethereum.validateAuthorizationOfEstate(owner, estate);
                const parcels = yield this.project.getParcels();
                yield this.ethereum.validateParcelsInEstate(estate, parcels);
            }
            else {
                const parcel = yield this.project.getParcelCoordinates();
                yield this.ethereum.validateAuthorizationOfParcel(owner, parcel);
            }
        });
    }
}
exports.Decentraland = Decentraland;
