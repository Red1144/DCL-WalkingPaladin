"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const fetch = require("isomorphic-fetch");
const CSV = require("comma-separated-values");
const eth_connect_1 = require("eth-connect");
const env_1 = require("../utils/env");
const errors_1 = require("../utils/errors");
const coordinateHelpers_1 = require("../utils/coordinateHelpers");
const MANAToken_json_1 = require("../../abi/MANAToken.json");
const LANDRegistry_json_1 = require("../../abi/LANDRegistry.json");
const EstateRegistry_json_1 = require("../../abi/EstateRegistry.json");
const provider = process.env.RPC_URL || env_1.getProvider();
const requestManager = new eth_connect_1.RequestManager(new eth_connect_1.providers.HTTPProvider(provider));
const manaFactory = new eth_connect_1.ContractFactory(requestManager, MANAToken_json_1.abi);
const landFactory = new eth_connect_1.ContractFactory(requestManager, LANDRegistry_json_1.abi);
const estateFactory = new eth_connect_1.ContractFactory(requestManager, EstateRegistry_json_1.abi);
const factories = new Map();
factories.set('MANAToken', manaFactory);
factories.set('LANDProxy', landFactory);
factories.set('EstateProxy', estateFactory);
/**
 * Events emitted by this class:
 *
 * ethereum:get-ipns         - An attempt to load landData from the ethereum blockchain
 * ethereum:get-ipns-empty   - No IPNS was found on the blockchain
 * ethereum:get-ipns-success - Successfully fetched and parsed landData
 */
class Ethereum extends events_1.EventEmitter {
    static getContractAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.addresses) {
                return this.addresses;
            }
            try {
                const raw = yield fetch('https://contracts.decentraland.org/addresses.json');
                this.addresses = yield raw.json();
                return this.addresses;
            }
            catch (error) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch decentraland contracts from "https://contracts.decentraland.org/addresses.json", error: ${error.message}`);
            }
        });
    }
    static getContractAddress(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getContractAddresses();
            return addresses[env_1.isDev ? 'ropsten' : 'mainnet'][name];
        });
    }
    static getContract(name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.contracts.get(name)) {
                return this.contracts.get(name);
            }
            const address = yield this.getContractAddress(name);
            const factory = factories.get(name);
            const contract = yield factory.at(address);
            this.contracts.set(name, contract);
            return contract;
        });
    }
    getLandOf(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('LANDProxy');
            try {
                const [x, y] = yield contract['landOf'](address.toUpperCase());
                return x.map(($, i) => ({ x: $.toNumber(), y: y[i].toNumber() }));
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LANDs: ${e.message}`);
            }
        });
    }
    getEstatesOf(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            try {
                const balance = yield contract['balanceOf'](address);
                const requests = [];
                for (let i = 0; i < balance; i++) {
                    const request = contract['tokenOfOwnerByIndex'](address, i);
                    requests.push(request);
                }
                return Promise.all(requests);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch Estate IDs of owner: ${e.message}`);
            }
        });
    }
    getLandData({ x, y }) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('LANDProxy');
            try {
                const landData = yield contract['landData'](x, y);
                return this.decodeLandData(landData);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LAND data: ${e.message}`);
            }
        });
    }
    getEstateData(estateId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            try {
                const landData = yield contract['getMetadata'](estateId);
                return this.decodeLandData(landData);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LAND data: ${e.message}`);
            }
        });
    }
    getLandOwner({ x, y }) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('LANDProxy');
            try {
                return yield contract['ownerOfLand'](x, y);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LAND owner: ${e.message}`);
            }
        });
    }
    getEstateOwner(estateId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            try {
                return yield contract['ownerOf'](estateId);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LAND owner: ${e.message}`);
            }
        });
    }
    /**
     * It fails if the owner address isn't able to update given parcel (as an owner or operator)
     */
    validateAuthorizationOfParcel(owner, parcel) {
        return __awaiter(this, void 0, void 0, function* () {
            const isLandOperator = yield this.isLandOperator(parcel, owner);
            if (!isLandOperator) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Provided address ${owner} is not authorized to update LAND ${parcel.x},${parcel.y}`);
            }
        });
    }
    /**
     * It fails if the owner address isn't able to update given estate ID (as an owner or operator)
     */
    validateAuthorizationOfEstate(owner, estateId) {
        return __awaiter(this, void 0, void 0, function* () {
            const isEstateOperator = yield this.isEstateOperator(estateId, owner);
            if (!isEstateOperator) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Provided address ${owner} is not authorized to update Estate ${estateId}`);
            }
        });
    }
    /**
     * It fails if the given parcels aren't inside the given estate
     */
    validateParcelsInEstate(estateId, parcels) {
        return __awaiter(this, void 0, void 0, function* () {
            const lands = yield this.getLandOfEstate(estateId);
            const incorrectParcel = lands.find(parcel => !parcels.some(p => coordinateHelpers_1.isEqual(parcel, p)));
            if (incorrectParcel) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `LAND ${incorrectParcel.x},${incorrectParcel.y} is not included at Estate ${estateId}`);
            }
        });
    }
    /**
     * Queries the Blockchain and returns the IPNS return by `landData`
     * @param coordinates An object containing the base X and Y coordinates for the parcel.
     */
    getIPNS(x, y) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('ethereum:get-ipns', x, y);
            const landData = yield this.getLandData({ x, y });
            if (!landData || !landData.ipns) {
                this.emit('ethereum:get-ipns-empty');
                return null;
            }
            this.emit('ethereum:get-ipns-success');
            return landData.ipns.replace('ipns:', '');
        });
    }
    getLandOfEstate(estateId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            const landContract = yield Ethereum.getContract('LANDProxy');
            try {
                const estateSize = yield contract['getEstateSize'](estateId);
                let promiseParcels = [];
                for (let i = 0; i < estateSize; i++) {
                    const request = contract['estateLandIds'](estateId, i).then(p => {
                        return landContract['decodeTokenId']([p]);
                    });
                    promiseParcels.push(request);
                }
                const parcels = (yield Promise.all(promiseParcels)).map(data => coordinateHelpers_1.getObject(data));
                return parcels;
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LANDs of Estate: ${e.message}`);
            }
        });
    }
    getEstateIdOfLand({ x, y }) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            const landContract = yield Ethereum.getContract('LANDProxy');
            try {
                const assetId = yield landContract['encodeTokenId'](x, y);
                return yield contract['getLandEstateId'](assetId);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch Estate ID of LAND: ${e.message}`);
            }
        });
    }
    isLandOperator({ x, y }, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('LANDProxy');
            try {
                const assetId = yield contract['encodeTokenId'](x, y);
                return yield contract['isUpdateAuthorized'](owner, assetId.toString());
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch LAND authorization: ${e.message}`);
            }
        });
    }
    isEstateOperator(estateId, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield Ethereum.getContract('EstateProxy');
            try {
                return yield contract['isUpdateAuthorized'](owner, estateId);
            }
            catch (e) {
                errors_1.fail(errors_1.ErrorType.ETHEREUM_ERROR, `Unable to fetch Estate authorization: ${e.message}`);
            }
        });
    }
    decodeLandData(data = '') {
        // this logic can also be found in decentraland-eth, but we can't rely on node-hid
        const version = data.charAt(0);
        switch (version) {
            case '0': {
                const [, name, description, ipns] = CSV.parse(data)[0];
                return { version: 0, name: name || null, description: description || null, ipns: ipns || null };
            }
            default:
                return null;
        }
    }
}
Ethereum.contracts = new Map();
exports.Ethereum = Ethereum;
