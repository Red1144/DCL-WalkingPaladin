"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer = require("inquirer");
const wrapCommand_1 = require("../utils/wrapCommand");
const moduleHelpers_1 = require("../utils/moduleHelpers");
const Project_1 = require("../lib/Project");
const analytics_1 = require("../utils/analytics");
const logging_1 = require("../utils/logging");
const Decentraland_1 = require("../lib/Decentraland");
const errors_1 = require("../utils/errors");
const utils_1 = require("../utils");
function init(vorpal) {
    vorpal
        .command('init')
        .description('Generates new Decentraland scene.')
        .option('--path <path>', 'output path (default is the current working directory).')
        .option('--boilerplate', 'static, singleplayer or multiplayer')
        .action(wrapCommand_1.wrapCommand((args) => __awaiter(this, void 0, void 0, function* () {
        const dcl = new Decentraland_1.Decentraland({
            workingDir: args.options.path
        });
        yield dcl.project.validateNewProject();
        const isEmpty = yield dcl.project.isProjectDirEmpty();
        if (!isEmpty) {
            const results = yield inquirer.prompt({
                type: 'confirm',
                name: 'continue',
                message: logging_1.warning(`Project directory isn't empty. Do you want to continue?`)
            });
            if (!results.continue) {
                process.exit(0);
            }
        }
        const sceneMeta = {
            display: { title: dcl.project.getRandomName() },
            contact: {
                name: '',
                email: ''
            },
            owner: '',
            scene: {
                parcels: ['0,0'],
                base: '0,0'
            },
            communications: {
                type: 'webrtc',
                signalling: 'https://rendezvous.decentraland.org'
            },
            policy: {
                fly: true,
                voiceEnabled: true,
                blacklist: [],
                teleportPosition: '0,0,0'
            },
            main: 'scene.xml'
        };
        const boilerplateType = utils_1.getOrElse(args.options.boilerplate, Project_1.BoilerplateType.TYPESCRIPT_STATIC);
        let websocketServer;
        if (boilerplateType === Project_1.BoilerplateType.WEBSOCKETS) {
            const ws = yield inquirer.prompt({
                type: 'input',
                name: 'server',
                message: `Your websocket server`,
                default: 'ws://localhost:8087'
            });
            websocketServer = ws.server;
        }
        yield dcl.init(sceneMeta, boilerplateType, websocketServer);
        if (yield dcl.project.needsDependencies()) {
            if (yield moduleHelpers_1.isOnline()) {
                const spinner = logging_1.loading('Installing dependencies');
                yield moduleHelpers_1.installDependencies(true);
                spinner.succeed('Dependencies installed');
            }
            else {
                errors_1.fail(errors_1.ErrorType.PREVIEW_ERROR, 'Unable to install dependencies: no internet connection');
            }
        }
        analytics_1.Analytics.sceneCreated({ boilerplateType });
        vorpal.log(logging_1.positive(`\nSuccess! Run 'dcl start' to see your scene\n`));
        vorpal.log(logging_1.bold(`Edit "parcels" property at scene.json to make your scene fit your estate.`));
    })));
}
exports.init = init;
