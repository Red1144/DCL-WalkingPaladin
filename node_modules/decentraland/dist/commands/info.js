"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const wrapCommand_1 = require("../utils/wrapCommand");
const logging_1 = require("../utils/logging");
const Decentraland_1 = require("../lib/Decentraland");
const analytics_1 = require("../utils/analytics");
const coordinateHelpers_1 = require("../utils/coordinateHelpers");
const command = 'info [target]';
const description = 'Displays information about the project, a LAND or a LAND owner\n';
const example = `
  Example usage:

    dcl info      - Returns the information of the current project
    dcl info 1,1  - Returns the information of the LAND located at the given coordinates
    dcl info 0x.. - Returns the information of all LANDs owned by the specified Ethereum address
    dcl info 5    - Returns the information of the Estate with the given ID
`;
function info(vorpal) {
    vorpal
        .command(command)
        .description(description)
        .option('-b, --blockchain', 'Retrieve information directly from our blockchain provider instead of our remote API.')
        .help(() => vorpal.log(`\n  Usage: ${command}\n\n  ${description}${example}`))
        .parse((command, args) => {
        // Vorpal doesn't like negative numbers (confused with flags), walkaround:
        const parts = args.split(' ');
        const target = parts.shift();
        const rest = parts.join(' ');
        if (coordinateHelpers_1.isValid(target)) {
            return `info coord:${target} ${rest}`;
        }
        else if (target.startsWith('0x')) {
            return `info address:${target} ${rest}`;
        }
        else if (Number.isInteger(parseInt(target, 10))) {
            return `info estate:${target} ${rest}`;
        }
        return command;
    })
        .action(wrapCommand_1.wrapCommand((args) => __awaiter(this, void 0, void 0, function* () {
        const dcl = new Decentraland_1.Decentraland({ blockchain: args.options.blockchain });
        if (!args.target) {
            yield dcl.project.validateExistingProject();
            const estateId = yield dcl.project.getEstate();
            if (estateId) {
                return infoEstate(vorpal, dcl, estateId);
            }
            const coords = yield dcl.project.getParcelCoordinates();
            return infoParcel(vorpal, dcl, coords);
        }
        if (args.target.startsWith('address:')) {
            const address = args.target.replace('address:', '');
            analytics_1.Analytics.infoCmd({ type: 'address', target: address });
            const { parcels, estates } = yield dcl.getAddressInfo(address);
            const formattedParcels = parcels.reduce((acc, parcel) => {
                return Object.assign({}, acc, { [`${parcel.x},${parcel.y}`]: { name: parcel.name, description: parcel.description, ipns: parcel.ipns } });
            }, {});
            const formattedEstates = estates.reduce((acc, estate) => {
                return Object.assign({}, acc, { [`ID ${estate.id.toString()}`]: { name: estate.name, description: estate.description, ipns: estate.ipns } });
            }, {});
            if (parcels.length === 0 && estates.length === 0) {
                return vorpal.log(logging_1.italic('\n  No information available\n'));
            }
            if (parcels.length !== 0) {
                vorpal.log(`\n  LAND owned by ${address}:\n`);
                vorpal.log(logging_1.formatDictionary(formattedParcels, { spacing: 2, padding: 2 }));
            }
            if (estates.length !== 0) {
                vorpal.log(`\n  Estates owned by ${address}:\n`);
                vorpal.log(logging_1.formatDictionary(formattedEstates, { spacing: 2, padding: 2 }));
            }
            return;
        }
        if (args.target.startsWith('coord:')) {
            const raw = args.target.replace('coord:', '');
            const coords = coordinateHelpers_1.getObject(raw);
            return infoParcel(vorpal, dcl, coords);
        }
        if (args.target.startsWith('estate:')) {
            const estateId = parseInt(args.target.replace('estate:', ''), 10);
            return infoEstate(vorpal, dcl, estateId);
        }
        vorpal.log(`\n  Invalid argument: ${args.target}`);
        vorpal.log(example);
    })));
}
exports.info = info;
function infoParcel(vorpal, dcl, coords) {
    return __awaiter(this, void 0, void 0, function* () {
        analytics_1.Analytics.infoCmd({ type: 'coordinates', target: coords });
        const estate = yield dcl.getEstateOfParcel(coords);
        const data = yield dcl.getParcelInfo(coords);
        return logInfo(vorpal, estate ? Object.assign({}, data, { estate }) : data);
    });
}
function infoEstate(vorpal, dcl, estateId) {
    return __awaiter(this, void 0, void 0, function* () {
        analytics_1.Analytics.infoCmd({ type: 'estate', target: estateId });
        const estate = yield dcl.getEstateInfo(estateId);
        return logEstate(vorpal, estate, estateId);
    });
}
function logInfo(vorpal, scene) {
    vorpal.log('\n  Scene Metadata:\n');
    if (scene.scene) {
        vorpal.log(logging_1.formatDictionary(scene.scene, { spacing: 2, padding: 2 }));
    }
    else {
        vorpal.log(logging_1.italic('    No information available\n'));
    }
    vorpal.log('  LAND Metadata:\n');
    if (scene.land) {
        vorpal.log(logging_1.formatDictionary(scene.land, { spacing: 2, padding: 2 }));
    }
    else {
        vorpal.log(logging_1.italic('    No information available\n'));
    }
    if (scene.estate) {
        logEstate(vorpal, scene.estate, null);
    }
}
exports.logInfo = logInfo;
function logEstate(vorpal, estate, id) {
    if (!estate) {
        vorpal.log(logging_1.italic(`\n  Estate with ID ${id} doesn't exist\n`));
        return;
    }
    vorpal.log('  Estate Metadata:\n');
    if (estate) {
        vorpal.log(logging_1.formatDictionary(estate, { spacing: 2, padding: 2 }));
    }
}
exports.logEstate = logEstate;
